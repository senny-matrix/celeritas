 package data

 import (
 	"crypto/rand"
 	"crypto/sha256"
 	"encoding/base32"
 	"errors"
 	"fmt"
 	up "github.com/upper/db/v4"
 	"log"
 	"net/http"
 	"strings"
 	"time"
 )

 type Token struct {
 	ID        int       `db:"id,omitempty" json:"id"`
 	UserID    int       `db:"user_id" json:"user_id"`
 	FirstName string    `db:"first_name" json:"first_name"`
 	Email     string    `db:"email" json:"email"`
 	PlainText string    `db:"token" json:"token"`
 	Hash      []byte    `db:"token_hash" json:"-"`
 	CreatedAt time.Time `db:"created_at" json:"created_at"`
 	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
 	Expires   time.Time `db:"expiry" json:"expires"`
 }

 func (t *Token) Table() string {
 	return "tokens"
 }

 func (t *Token) GetUserForToken(token string) (*User, error) {
 	var u User
 	var theToken Token

 	collection := upper.Collection(t.Table())
 	res := collection.Find(up.Cond{"token": token})

 	okay, err := res.Exists()
 	if err != nil {
 		return nil, err
 	}

 	if okay {
 		log.Println("found token: ", token)
 	}
 	if !okay {
 		return nil, errors.New("no matching token found")
 	}

 	err = res.One(&theToken)
 	if err != nil {
 		return nil, err
 	}

 	collection = upper.Collection("users")
 	res = collection.Find(up.Cond{"id": theToken.UserID})

 	err = res.One(&u)
 	if err != nil {
 		return nil, err
 	}

 	u.Token = theToken
 	return &u, nil
 }

 func (t *Token) GetTokensForUser(id int) ([]*Token, error) {
 	var tokens []*Token
 	collection := upper.Collection(t.Table())
 	res := collection.Find(up.Cond{"user_id": id})
 	err := res.All(&tokens)
 	if err != nil {
 		return nil, err
 	}
 	return tokens, nil
 }

 func (t *Token) Get(id int) (*Token, error) {
 	var theToken Token
 	collection := upper.Collection(t.Table())
 	res := collection.Find(up.Cond{"id": id})
 	err := res.One(&theToken)
 	if err != nil {
 		return nil, err
 	}
 	return &theToken, nil
 }

 func (t *Token) GetByToken(plainText string) (*Token, error) {
 	var theToken Token
 	collection := upper.Collection(t.Table())
 	res := collection.Find(up.Cond{"token": plainText})
 	err := res.One(&theToken)
 	if err != nil {
 		return nil, err
 	}
 	return &theToken, nil
 }

 func (t *Token) Delete(id int) error {
 	collection := upper.Collection(t.Table())
 	res := collection.Find(id)
 	exists, _ := res.Exists() // Check if the record exists
 	if !exists {
 		return fmt.Errorf("record with ID %d not found", id)
 	}

 	err := res.Delete()
 	if err != nil {
 		return fmt.Errorf("failed to delete record with ID %d: %w", id, err)
 	}

 	// Verify deletion
 	exists, _ = collection.Find(id).Exists()
 	if exists {
 		return fmt.Errorf("record with ID %d still exists after deletion", id)
 	}

 	return nil
 }

 func (t *Token) DeleteByToken(plainText string) error {
 	collection := upper.Collection(t.Table())
 	res := collection.Find(up.Cond{"token": plainText})

 	// Check if the token exists
 	exists, err := res.Exists()
 	if err != nil {
 		return err
 	}
 	if !exists {
 		return errors.New("token does not exist")
 	}

 	err = res.Delete()
 	if err != nil {
 		return err
 	}
 	return nil
 }

 func (t *Token) Insert(theToken Token, user User) error {
 	collection := upper.Collection(t.Table())

 	// Delete existing token
 	res := collection.Find(up.Cond{"user_id": user.ID})
 	err := res.Delete()
 	if err != nil {
 		return err
 	}

 	theToken.CreatedAt = time.Now()
 	theToken.UpdatedAt = time.Now()
 	theToken.FirstName = user.FirstName
 	theToken.Email = user.Email
 	// Not necessary
 	theToken.UserID = user.ID

 	_, err = collection.Insert(&theToken)
 	if err != nil {
 		return err
 	}
 	return nil
 }

 func (t *Token) GenerateToken(userID int, ttl time.Duration) (*Token, error) {
 	token := &Token{
 		UserID:  userID,
 		Expires: time.Now().Add(ttl),
 	}

 	randomBytes := make([]byte, 16)
 	_, err := rand.Read(randomBytes)
 	if err != nil {
 		return nil, err
 	}
 	token.PlainText = base32.StdEncoding.
 		WithPadding(base32.NoPadding).
 		EncodeToString(randomBytes)
 	hash := sha256.Sum256([]byte(token.PlainText))
 	token.Hash = hash[:]
 	return token, nil
 }

 func (t *Token) AuthenticateToken(r *http.Request) (*User, error) {
 	authorizationHeader := r.Header.Get("Authorization")
 	if authorizationHeader == "" {
 		return nil, errors.New("no authorization header received")
 	}

 	headerParts := strings.Split(authorizationHeader, " ")
 	if len(headerParts) != 2 || headerParts[0] != "Bearer" {
 		return nil, errors.New("no authorization header received")
 	}

 	token := headerParts[1]

 	if len(token) != 26 {
 		return nil, errors.New("token wrong size")
 	}

 	tkn, err := t.GetByToken(token)
 	if err != nil {
 		return nil, errors.New("no matching token found")
 	}

 	if tkn.Expires.Before(time.Now().UTC()) {
 		return nil, errors.New("expired token")
 	}

 	user, err := t.GetUserForToken(token)
 	if err != nil {
 		return nil, errors.New("no matching user found")
 	}

 	return user, nil
 }

 func (t *Token) ValidToken(token string) (bool, error) {
 	user, err := t.GetUserForToken(token)
 	if err != nil {
 		return false, errors.New("no matching user found")
 	}

 	if user.Token.PlainText == "" {
 		return false, errors.New("no matching token found")
 	}

 	if user.Token.Expires.Before(time.Now()) {
 		return false, errors.New("expired token")
 	}

 	return true, nil
 }
